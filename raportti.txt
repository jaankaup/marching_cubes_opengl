MARCHING CUBES ALGORITMIT TOTEUTUS OPENGL:LLÄ

Ohjelma luo proseduraalista grafiikka ns. marching cubes algoritmia hyödyntäen. Ohjelmassa voi tutkailla hiirellä ja näpäimistöä käyttäen muutamia esimerkkimalleja. 

Ohjelmointikielenä on käytetty c++:aa ja opengl toteutuksessa on käytetty GLSL:ää. Marching cubes algoritmi on toteuttu kokonaan GLSL:ssä. GLSL versio on 430, joten vanhat näytönohjaimet eivät todennäköisesti pysty suorittamaan tätä ohjelmaa.  

Alunperin tarkoituksena oli tehdä webassembly toteutus siten, että c++ koodi olisi käännetty emscripten kääntäjällä webassemblyksi. Näin ohjelman olisi saannut toimimaan web-selaimessa. Marching cubes algoritmi toimikin web-selain versiossa, mutta pullonkaulaksi muodostui se että marching cubes oli toteutettu c++:lla. Näin ollen algoritmin suorituskyky selaimessa oli todella huono. Tästä syystä aloin totetuttamaan marching cubesia siten, että se toimisi täysin GPU:ssa. Luonnollinen toteutus marching cubesille on esimerkiksi geometry shaderissa, mutta osoittausui että webgl ei tuo geometryshaderia. Koska webgl ei tukenut geometry shaderia, ohjelman kehitys keskittyi täysin natiivin c++:n tekemiseen. Ilmeisesti webgl on teknologia jota ei enää kehitetä, vaan tilalle on tulossa uusi standardi nimeltään webgpu. Tosin tämä teknologia ei tosin ole vielä käytössä. 

Ohjelman toiminnot:

A = liiku vasemmalle.
W = liiku ylös.
D = liiku oikealle.
S = liiku alas.

T = Luo uusi 3D tekstuuri ja päivitä scene.
Y = Luo uusi 3D tekstuuri (octave versio) ja päivitä scene.

+ = Kasvattaa voxels per block arvoa kahdella.
- = Vähentää voxels per block arvoa.

Voxels per block tarkoittaa sitä, kuinka moneen osaan isompi tarkasteltava kuutio jaetaan. Esim. jos arvo on 32, niin tällöin kukin scenessä oleva yksikkökuutio 
jakautuu 32x32x32 pienemmäksi kuutioksi jotka sitten marssitaan läpi.

0-9 numerot ovat varattuja eri mallien latausta varten. Algoritmi pysyy täysin samana, mutta vain skalaarikentän määritys funktio muuttuu.

Eli marching cubes shader koostuu kahdesta shaderista (triangulate.vert ja triangulate.geom):

triangulate.vert ottaa vastaan yhden kuution kulmapisteen 'layout(location = 0) in vec3 in_position' ja isomman kuution position koordinaatistossa 'layout(location = 1) in vec3 in_basePosition'. Isoja kuutioita on nyt tässä sovelluksessa 8*8*8 kappaletta. Kukin iso kuutio on jaettu pieniin kuutoihin (esim. 32x32x32) jotka kaikki marssitaan läpi kun luodaan geometriaa.

triangulate.geom ottaa vastaan triangulate.vert shaderista tulevan kuution pisteen koordinaatin ja luo suorittaa sille marching cubes algoritmin. Eli siellä luodaan kuutio perustuen kulmapisteen koordinaattiin ja voxel_per_block arvoon, joka kertoo kuution sivun pituuden. Algoritmi ottaa siis syötteen kuution etu/vasen kulmapisteen koordinaatin ja antaa ulostulona 0-5 kolmion pisteen niitä vastaavat normaalit. Algoritmi etenee seuraavasti:

1. Luodaan kuutio. 
2. Lasketaan jokaiselle kuution kulmapisteelle tiheysarvo (calculateDensity).
3. Tutkitaan jokaisen kulmapisteen kohdalla onko se pienempää kuin annettu isovalue. Nyt isovalue on hardkoodattu 0.0. Tämä arvo kertoo sen, mikä on skalaarikentässä olevan pinnan arvo. Kuution kulmapisteen kohdalla siis katsotaan onko se pienempi kuin isovalue. Jos tämä on tosi, niin silloin kuution kulmapiste on "kappaleen" sisäpuolella. Jos taas kulmapisteen arvo on suurempi kuin isovalue, niin tällöin kuution kulma on kappaleen ulkopuolella. Jos kaikki kuution kulmat ovat joko kappaleen sisä- tai ulkopuolella, niin silloin ei synny geometriaa. Jos yksikin kulmapiste on kappaleen sisäpuolella ja toinen kulmapisten kappaleen ulkopuolella, niin sillin tiedetään että kuution on "uponnut" kappaleeseen, tai toisin sanoen kappaleen pinta kulkee jossakin kuution sisällä. Tällöin kuutio tuottaa geometriaa.  
4. Lasketaan edellisen kohdan perusteella niin sanottu cube case. Erilaisia erilaisia vaihtoehtoja on kaiken kaikkiaan 255. Tapaus 0 tarkoittaa sitä että kaikki kuution kulmapisteet ovat kappaleen sisäpuolella ja 255 tarkoittaa sitä että kaikki kulmapisteet ovat kappaleen ulkopuolella. 1-254 tuottavat kolmioita. 
5. Selvitetään cube casen perusteella mihin kuution sivuihin tulee kolmion leikauskohdat. Tämä on taulukoitu Texture luokassa Texture::create_tritable_texture(). Tämä taulukko oli liian suuri vietäväksi GLSL:ään sellaisenaan (rekisterit loppuivat kesken), joten ko. arvot ovat koodatu 1D tekstuurin pikseleiden arvoksi ja tuotu sitten shaderille uniform muuttujaan tri_tabel. Casen perusteella saadaan tästä 1D tekstuurista tieto mitkä kuution sivut leikkaantuvat ja kuinka monta kolmiota tuotetaan. 
6. Luodaan ja interpoloidaan kolmiot.
7. Luodaan vastaavat kolmion normaalit. Normaali lasketaan tiheusfunktiolla kuution kulmapisteen naapureiden tiheysarvojen perusteella. Tämän jälkeen normaali interpoloidaan ja normalisoidaan.
8. Geomtery shader tuottaa ulos siis kolmioita ja niitä vastaavat normaalit interleaved datana.

Tämä toistetaan jokaisen kuutio kohdalla. Jos voxels per block on 32, niin läpi käydään 8*8*8*32*32*32 kuutiota. Lopputulos tallennetaan taulukkoon ohjelmassa ja luodaan tästä triangle meshistä piirrettävä kappale. Eli triangulate shaderi suoritetaan vain kerran ja sen tuottama kolmioverkkoa piirretään sitten näytölle. Tämä kolmioverkon luontiprosessi tapahtuu VertexBufferManager luokan optimize_vertex_buffer metodissa.

triangluate.geom funktio 'calculateDensity' määrää skalaarikentän eli sen mitä piirretään. calculateDensity funktiot ovat määritelty densityFunction{0-9}.df tiedostoissa, ja ohjelmassa painamalla 0-9 muuttuu tämä calculateDensity funktio. Tämän funktio sisältöä voi kuka tahansa modifioida ja katsoa sitten mitä piirretään. Ohjelma tosin kaatuu jos funtioon kirjoittaa virheitä, mutta ohjelma tulostaa siitä GLSL kääntäjän virheilmoituksen.

Lisäksi hyödynnetään satunaisesti luotua perlin noisea käyttäen 3D tekstuureita, joita hyödynnetään calculteDensity funktiossa. Painamalla joko t tai y näppäintä tekstuuri luodaan satunnaisesti uudestaan.  

Ohjelmasta on jätetty aikataulusyistä pois kuutioiden debuggaus toiminnot. Aiemmin scenessä pystyi liikkumaan kameran avulla ja kuutio ruudukko siirtyi kameran mukana. Joka piirtoframerssa suoritettiin marching cubes ja samalla pystyi katsomaan kuutoita wireframeina ja valitsemaan +/- nappuloilla eri kuution caset sekä sen mitä geometriaa ne piirtivät. Tarkoituksena oli luoda maailma jossa geometriaa luodaan loputtomiin marching cubesilla, mutta aika ei tähän riittänyt. 

Ohjelmassa on käytetty seuraavia kirjastoa: SDL2, GLEW, SOIL ja PerlinNoise (https://github.com/Reputeless/PerlinNoise).
Lisäksi apuna on ollut GPU Gems 3 part 1 Chapter 1. Generatin Complex Procedural Terrains Using the GPU ja paulbourke.net/geometry/polygonise/.
